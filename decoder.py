from math import gcd

# Given values
n = 350125132321614675486271501838021287031528910148942324087763320454630714583695139498073169535862923563193883847493076029904404686079085309699447558127711419170277993485461948945398415664507715720352091551529510728086668182630251961601271652493065480532685454543042010566057416981997598301645122728191110622561
c = 86001821735932284950285945447396673662181480415603949035221089818546238793571258038681864350826180659296881722896900362173172648307336760058587574599696571375678976442054948662319846035378397325310172897620791667086853591089743334479674514387455720233754111751682511390248597715752626097773966786638569760316
p = 13231121122596049220370083021522008697208290156186352967808989831823556760032197896288422205294801087286506364317749929928269173677376133255442515462666017
q = 26462242245192098440740166043044017394416580312372705935617979663647113520064395792576844410589602174573012728635499859856538347354752266510885030925332033
e = 65537

# Compute Ï†(n)
phi = (p - 1) * (q - 1)

# Compute d (modular inverse of e mod phi)
def extended_gcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = extended_gcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = extended_gcd(a, m)
    if g != 1:
        return None  # No inverse exists
    else:
        return x % m

d = modinv(e, phi)

# Decrypt m = c^d mod n
m = pow(c, d, n)

# Try to decode m as text
try:
    byte_length = (m.bit_length() + 7) // 8
    message_bytes = m.to_bytes(byte_length, 'big')
    message = message_bytes.decode('utf-8')
    print("Decrypted message:", message)
except:
    print("Decrypted message (as integer):", m)